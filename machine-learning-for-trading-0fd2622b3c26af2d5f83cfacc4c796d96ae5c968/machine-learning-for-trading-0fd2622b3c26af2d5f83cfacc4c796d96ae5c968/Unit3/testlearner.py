"""Determines when a stock should be traded by predicting the price 5 days in the future 
using a K Nearest Neighbors learner and displays the value of that portfolio over the data
used to train as well as an independent set of test data"""

import sys
import numpy as np
import math
import KNNLearner as knn
import pandas as pd
import matplotlib.pyplot as plt
import os, datetime
from utils.util import get_data, plot_data, symbol_to_path
from Unit1.analysis import get_portfolio_value, get_portfolio_stats, plot_normalized_data
from Unit2.trade_simulator import calculate_portfolio_value


"""Using a learner provided in the main method, this method uses the predicted future stock
prices to generate a .csv file of when trades should be made. All trades are in increments of 100
by default"""
def run_simulation(learner, prices_all, stock, xData, yData, dates, orders_filename):
    predY = learner.query(xData)
    rmse = math.sqrt(((yData - predY) ** 2).sum()/len(yData.index))
    final_vals = pd.DataFrame(index=dates)
    final_vals['pred_y'] = predY
    final_vals['actual_y'] = prices_all[stock].shift(periods = -5)
    correlation = final_vals.corr()
    final_vals['current_price'] = prices_all[stock]
    final_vals = final_vals.dropna(subset=['current_price'])

    #print the error and correlation of predictions. This indicates how effective the KNN learner is
    print "Root Mean Squared Error of Predictions: ", rmse
    print "correlation: ", correlation.iloc[0,1]
    plot = final_vals[['pred_y','actual_y']].plot(title = "Actual Price Versus Predicted Price")
    plot.set_xlabel("Date")
    plot.set_ylabel("Price")
    plt.show()

    #based on predicted future prices, determine when to buy or sell stocks based on method described in readme
    long_entries = []
    short_entries = []
    exits = []
    wait = 0
    buyorsell = ""
    f = open(orders_filename,'w')
    f.write("Date,Symbol,Order,Shares\n")

    for index, row in final_vals.iterrows():
        if wait > 1:
            wait-=1;
            continue

        elif wait == 1:
            if buyorsell =="buy":
                exits.append(str(index)[:10])
                f.write("{},{},SELL,100\n".format(str(index)[:10], stock))

            elif buyorsell == "sell":
                exits.append(str(index)[:10])
                f.write("{},{},BUY,100\n".format(str(index)[:10], stock))

            wait-=1
            continue

        if ((final_vals.loc[index,'pred_y']/final_vals.loc[index,'current_price'])-1 > .05):
            long_entries.append(str(index)[:10])
            f.write("{},{},BUY,100\n".format(str(index)[:10], stock))
            wait = 5
            buyorsell = "buy"


        elif ((final_vals.loc[index,'pred_y']/final_vals.loc[index,'current_price'])-1 < -.05):
            short_entries.append(str(index)[:10])
            f.write("{},{},SELL,100\n".format(str(index)[:10], stock))
            wait = 5
            buyorsell = "sell"

    f.close()

    #Plot the trade opportunities generated by the above method. Green lines are buying long, red short selling, and black leaving the previous state
    ax = final_vals['current_price'].plot(fontsize=12)
    ax.set_xlabel("Date")
    ax.set_ylabel("Prices")
    for i, val in enumerate(long_entries):
        ax.axvline(x=val, ymin=0, ymax = 100, linewidth=.5, color='green')
    for i, val in enumerate(short_entries):
        ax.axvline(x=val, ymin=0, ymax = 100, linewidth=.5, color='red')
    for i, val in enumerate(exits):
        ax.axvline(x=val, ymin=0, ymax = 100, linewidth=.5, color='black')
    plt.show()


"""Runs the implementation of the KNN learner based trading strategy. Optional inputs are
Stock: THe ticker symbol of the stock you would like to calculate a trading strategy for. Defaults to IBM
The date parameters are not adjustable via command line but may be in a future version. For now all
simulations will run over the dates provided."""
def run():
    # Define default parameters
    start_date = '2008-01-01'
    end_date = '2009-12-31'
    start_test_date = '2010-01-01'
    end_test_date = '2010-12-31'
    stock = 'IBM'

    #check for user input of stocks and date range
    if (len(sys.argv) > 1):
        file_path = "data/" + sys.argv[1] + ".csv"
        # Check if that file exists
        if not os.path.exists(file_path) or not os.path.isfile(file_path):
            print 'Data for the stock specified does not exist. Please reference stocks in the data folder, or run with no option provided (will display IBM data by default)'
            return
        stock = sys.argv[1]

    dates = pd.date_range(start_date, end_date)
    test_dates = pd.date_range(start_test_date, end_test_date)

    #read in data that you're going to use
    prices_all = get_data([stock], dates)  # automatically adds SPY
    test_prices_all = get_data([stock], test_dates)

    #set up dataframe to train learner over 
    data = pd.DataFrame(index=dates)
    data['actual_prices'] = prices_all[stock]
    data['bb_value'] = prices_all[stock] - pd.rolling_mean(prices_all[stock], window=5)
    data['bb_value'] = data['bb_value'] / (pd.rolling_std(prices_all[stock], window = 5) * 2) 
    data['momentum'] = (prices_all[stock]/prices_all[stock].shift(periods = -5)) - 1
    data['volatility'] = pd.rolling_std(((prices_all[stock]/prices_all[stock].shift(periods = -1)) - 1), window = 5)
    data['y_values'] = prices_all[stock].shift(periods = -5)
    data = data.dropna(subset=['actual_prices'])
    trainX = data.iloc[4:,0:-1]
    trainY = data.iloc[4:,-1]

    #set up data frame to test learner over
    test_data = pd.DataFrame(index=test_dates)
    test_data['actual_prices'] = test_prices_all[stock]
    test_data['bb_value'] = test_prices_all[stock] - pd.rolling_mean(test_prices_all[stock], window=5)
    test_data['bb_value'] = test_data['bb_value'] / (pd.rolling_std(test_prices_all[stock], window = 5) * 2) 
    test_data['momentum'] = (test_prices_all[stock]/test_prices_all[stock].shift(periods = -5)) - 1
    test_data['volatility'] = pd.rolling_std(((test_prices_all[stock]/test_prices_all[stock].shift(periods = -1)) - 1), window = 5)
    test_data['y_values'] = test_prices_all[stock].shift(periods = -5)
    test_data = test_data.dropna(subset=['actual_prices'])
    testX = test_data.iloc[:,0:-1]
    testY = test_data.iloc[:,-1]

    #create a KNN Learner for the data and add evidence to it
    learner = knn.KNNLearner(3) 
    learner.addEvidence(trainX, trainY)

    #run a simulation of the trading strategy based on predicted future values over training data
    print "\nTraining Data Results:"
    run_simulation(learner, prices_all, stock, trainX, trainY, dates, "Unit3/orders/orders_trainingdata.csv")
    calculate_portfolio_value("Unit3/orders/orders_trainingdata.csv", prices_all, dates, stock)

    #run a simulation of the trading strategy over previously unseen testing data to test it's performance
    print "\nTest Data Results:"
    run_simulation(learner, test_prices_all, stock, testX, testY, test_dates, "Unit3/orders/orders_testdata.csv")
    calculate_portfolio_value("Unit3/orders/orders_testdata.csv", test_prices_all, test_dates, stock)
    


if __name__ == "__main__":
    run()